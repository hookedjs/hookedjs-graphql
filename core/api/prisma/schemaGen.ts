import * as fs from 'fs'
import * as glob from 'glob'
import * as path from 'path'

const datasource = fs.readFileSync('prisma/datasource.prisma')

const hookedjsModuleFiles =
  fs.readdirSync(path.join(__dirname, '../../../modules/'))
    .filter(p => !['.DS_Store', 'api', 'react', 'common'].includes(p))
    .map(p => glob.sync(path.resolve(__dirname, `../../../modules/${p}/api/**/*.prisma`)))
    .reduce((acc, val) => acc.concat(val), []) // is like .flat(1) but ts no likey

const moduleFiles = [
  ...glob.sync('src/**/*.prisma', {}),
  ...hookedjsModuleFiles,
]

const modules = moduleFiles.reduce((a,f) => {
  const module = fs.readFileSync(f)
  return a + module
}, '')

const schemaRaw = datasource + modules
const schemaMerged = '// This file was generated by schemaGen.ts\n' + prismaSchemaMergeExtends(schemaRaw)

fs.writeFileSync('prisma/schema.prisma', schemaMerged)
console.log('schemaGen.ts: Prisma Schema Generated')

function prismaSchemaMergeExtends(schema: string) {
  const noExtends = schema.replace(/extends [^{]*[^}]*\}/sg, '')
  const onlyExtends = schema.match(/extends [^{]*[^}]*\}/sg) || []

  let merged = noExtends
  onlyExtends.forEach(extension => {
    const [_, extendsTo, extendsWith] = extension.match(/extends ([^ ]* [^ ]*) \{([^}]*)/) as string[]
    const extendsToRegExp = new RegExp(`${extendsTo}[^}]*}`)
    const extendsToNext = merged.match(extendsToRegExp)![0].replace('}', extendsWith + '}')
    // process.stdout.write(JSON.stringify(test, null, 2).replace(/\\n/g, '\n'))
    merged = merged.replace(extendsToRegExp, extendsToNext)
  })
  return merged
}